/*
  Copyright 2013 Google LLC All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at:

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

/*
   american fuzzy lop - wrapper for GNU as
   ---------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   The sole purpose of this wrapper is to preprocess assembly files generated
   by GCC / clang and inject the instrumentation bits included from afl-as.h. It
   is automatically invoked by the toolchain when compiling programs using
   afl-gcc / afl-clang.

   Note that it's an explicit non-goal to instrument hand-written assembly,
   be it in separate .s files or in __asm__ blocks. The only aspiration this
   utility has right now is to be able to skip them gracefully and allow the
   compilation process to continue.

   That said, see experimental/clang_asm_normalize/ for a solution that may
   allow clang users to make things work even with hand-crafted assembly. Just
   note that there is no equivalent for GCC.

*/

#define AFL_MAIN

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"

#include "afl-as.h"

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>

#include <sys/wait.h>
#include <sys/time.h>
#include <assert.h>

static u8** as_params;          /* Parameters passed to the real 'as'   */

static u8*  input_file;         /* Originally specified input file      */
static u8*  modified_file;      /* Instrumented file for the real 'as'  */

static u8   be_quiet,           /* Quiet mode (no stderr output)        */
            clang_mode,         /* Running in clang mode?               */
            pass_thru,          /* Just pass data through?              */
            just_version,       /* Just show version?                   */
            sanitizer;          /* Using ASAN / MSAN                    */

static u32  inst_ratio = 100,   /* Instrumentation probability (%)      */
            as_par_cnt = 1;     /* Number of params to 'as'             */

/* If we don't find --32 or --64 in the command line, default to 
   instrumentation for whichever mode we were compiled with. This is not
   perfect, but should do the trick for almost all use cases. */

// #ifdef WORD_SIZE_64

// static u8   use_64bit = 1;

// #else

static u8   use_64bit = 0;

// #ifdef __APPLE__
// #  error "Sorry, 32-bit Apple platforms are not supported."
// #endif /* __APPLE__ */

// #endif /* ^WORD_SIZE_64 */


/* Examine and modify parameters to pass to 'as'. Note that the file name
   is always the last parameter passed by GCC, so we exploit this property
   to keep the code simple. */

static void edit_params(int argc, char** argv) {

  u8 *tmp_dir = getenv("TMPDIR"), *afl_as = getenv("AFL_AS");
  u32 i;

#ifdef __APPLE__

  u8 use_clang_as = 0;

  /* On MacOS X, the Xcode cctool 'as' driver is a bit stale and does not work
     with the code generated by newer versions of clang that are hand-built
     by the user. See the thread here: http://goo.gl/HBWDtn.

     To work around this, when using clang and running without AFL_AS
     specified, we will actually call 'clang -c' instead of 'as -q' to
     compile the assembly file.

     The tools aren't cmdline-compatible, but at least for now, we can
     seemingly get away with this by making only very minor tweaks. Thanks
     to Nico Weber for the idea. */

  if (clang_mode && !afl_as) {

    use_clang_as = 1;

    afl_as = getenv("AFL_CC");
    if (!afl_as) afl_as = getenv("AFL_CXX");
    if (!afl_as) afl_as = "clang";

  }

#endif /* __APPLE__ */

  /* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR
     is not set. We need to check these non-standard variables to properly
     handle the pass_thru logic later on. */

  if (!tmp_dir) tmp_dir = getenv("TEMP");
  if (!tmp_dir) tmp_dir = getenv("TMP");
  if (!tmp_dir) tmp_dir = "/tmp";

  as_params = ck_alloc((argc + 32) * sizeof(u8*));

  as_params[0] = afl_as ? afl_as : (u8*)"arm-none-eabi-as";

  as_params[argc] = 0;

  for (i = 1; i < argc - 1; i++) {

    // if (!strcmp(argv[i], "--64")) use_64bit = 1;
    // else if (!strcmp(argv[i], "--32")) use_64bit = 0;

#ifdef __APPLE__

    /* The Apple case is a bit different... */

    if (!strcmp(argv[i], "-arch") && i + 1 < argc) {

      if (!strcmp(argv[i + 1], "x86_64")) use_64bit = 1;
      else if (!strcmp(argv[i + 1], "i386"))
        FATAL("Sorry, 32-bit Apple platforms are not supported.");

    }

    /* Strip options that set the preference for a particular upstream
       assembler in Xcode. */

    if (clang_mode && (!strcmp(argv[i], "-q") || !strcmp(argv[i], "-Q")))
      continue;

#endif /* __APPLE__ */

    as_params[as_par_cnt++] = argv[i];

  }

#ifdef __APPLE__

  /* When calling clang as the upstream assembler, append -c -x assembler
     and hope for the best. */

  if (use_clang_as) {

    as_params[as_par_cnt++] = "-c";
    as_params[as_par_cnt++] = "-x";
    as_params[as_par_cnt++] = "assembler";

  }

#endif /* __APPLE__ */

  input_file = argv[argc - 1];

  if (input_file[0] == '-') {

    if (!strcmp(input_file + 1, "-version")) {
      just_version = 1;
      modified_file = input_file;
      goto wrap_things_up;
    }

    if (input_file[1]) FATAL("Incorrect use (not called through afl-gcc?)");
      else input_file = NULL;

  } else {

    /* Check if this looks like a standard invocation as a part of an attempt
       to compile a program, rather than using gcc on an ad-hoc .s file in
       a format we may not understand. This works around an issue compiling
       NSS. */


  }

  modified_file = alloc_printf("%s/.afl-%u-%u.s", tmp_dir, getpid(),
                               (u32)time(NULL));

wrap_things_up:

  as_params[as_par_cnt++] = modified_file;
  as_params[as_par_cnt]   = NULL;

}


/* Process input file, generate modified_file. Insert instrumentation in all
   the appropriate places. */

static void add_instrumentation(void) {

  static u8 line[MAX_LINE];

  FILE* inf;
  FILE* outf;
  s32 outfd;
  u32 ins_lines = 0;

  u8 instrument_next = 0;
  u8 instrument_main = 0;
  char it_t[2];
  char it_e[2];
  char it_cond[2];

#ifdef __APPLE__

  u8* colon_pos;

#endif /* __APPLE__ */

  if (input_file) {

    inf = fopen(input_file, "r");
    if (!inf) PFATAL("Unable to read '%s'", input_file);

  } else inf = stdin;

  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);

  if (outfd < 0) PFATAL("Unable to write to '%s'", modified_file);

  outf = fdopen(outfd, "w");

  if (!outf) PFATAL("fdopen() failed");  

  while (fgets(line, MAX_LINE, inf)) {
    if(instrument_main && line[0] == '\t' && line[1] != '.' && line[1] != '@'){ // main should be instrument with init
      fputs(main_asan_init_fmt_32, outf);
      ins_lines++;
      instrument_main = 0;
    }
    if(instrument_next && line[0] == '\t' && line[1] != '.' && line[1] != '@'){ // block first instruction should be instrument
      fprintf(outf, trampoline_fmt_32, R(MAP_SIZE));
      ins_lines++;
      instrument_next = 0;
    }
    fputs(line, outf);
    
    if(line[0] != '\t'){ // symbol line, indicating maybe new basic block
      instrument_next = 1;
      if(strncmp(line, "main:", 5)==0){// check if main()
        instrument_main = 1;
      }
    }else{ // instruction line
      if(line[1] != '.' && line[1] != '@'){
        char *p = strtok(line, "\t");
        int p_len = strlen(p);
        if(p_len > 2){
          if(p[0]=='i' && p[1] == 't'){
            int it_len = p_len-1; // get IT instruction len
            char *it_e_loc = strchr(p, 'e'); // get e in IT location
            if(it_e_loc == NULL){
              assert(!"No e in IT");
            }
            int it_e_index = it_e_loc - p; 
            // get condition
            p = strtok(NULL, "\0");
            it_cond[0] = p[0];
            it_cond[1] = p[1];
            while(1){ // get T execute condition
              fgets(line, MAX_LINE, inf);
              fputs(line, outf);
              if(line[1] != '.' && line[1] != '@'){
                it_e_index--;
                it_len--;
                p = strtok(line, "\t");
                p_len = strlen(p);
                it_t[0] = p[p_len-2];
                it_t[1] = p[p_len-1];
                break;
              }
            }
            while(1){
              fgets(line, MAX_LINE, inf);
              fputs(line, outf);
              if(line[1] != '.' && line[1] != '@'){
                it_e_index--;
                it_len--;
                if(it_e_index == 0){ // find e conditional instruction
                  p = strtok(line, "\t");
                  int p_len = strlen(p);
                  it_e[0] = p[p_len-2];
                  it_e[1] = p[p_len-1];
                }
                if(it_len == 0){
                  break;
                }
              }
            }
            // insert it to output random number
            fprintf(outf, it_trampoline_fmt_32, it_cond[0], it_cond[1], it_t[0], it_t[1], R(MAP_SIZE), it_e[0], it_e[1], R(MAP_SIZE));
            ins_lines++;
          // conditional branch instruction
          }else if( (p[p_len-2] == 'e' && p[p_len-1] == 'q') || // eq
              (p[p_len-2] == 'n' && p[p_len-1] == 'e') || // ne
              (p[p_len-2] == 'c' && p[p_len-1] == 's') || // cs
              (p[p_len-2] == 'h' && p[p_len-1] == 's') || // hs
              (p[p_len-2] == 'c' && p[p_len-1] == 'c') || // cc
              (p[p_len-2] == 'l' && p[p_len-1] == 'o') || // lo
              (p[p_len-2] == 'm' && p[p_len-1] == 'i') || // mi
              (p[p_len-2] == 'p' && p[p_len-1] == 'l') || // pl
              (p[p_len-2] == 'h' && p[p_len-1] == 'i') || // hi
              (p[p_len-2] == 'l' && p[p_len-1] == 's' && strncmp(p, "smmls", 5)!=0 && strncmp(p, "mls", 3)!=0 ) || // ls but not smmls and mls
              (p[p_len-2] == 'g' && p[p_len-1] == 'e') || // ge
              (p[p_len-2] == 'l' && p[p_len-1] == 't') || // lt
              (p[p_len-2] == 'g' && p[p_len-1] == 't') || // gt
              (p[p_len-2] == 'l' && p[p_len-1] == 'e')    // le
          ){
            fprintf(outf, trampoline_fmt_32, R(MAP_SIZE));
            ins_lines++;
          }
        }
      }
    }
  }

  // if (ins_lines)
  //   fputs(use_64bit ? main_payload_64 : main_payload_32, outf);

  if (input_file) fclose(inf);
  fclose(outf);

  if (!be_quiet) {

    if (!ins_lines) WARNF("No instrumentation targets found%s.",
                          pass_thru ? " (pass-thru mode)" : "");
    else OKF("Instrumented %u locations (%s-bit, %s mode, ratio %u%%).",
             ins_lines, use_64bit ? "64" : "32",
             getenv("AFL_HARDEN") ? "hardened" : 
             (sanitizer ? "ASAN/MSAN" : "non-hardened"),
             inst_ratio);
 
  }

}


/* Main entry point */

int main(int argc, char** argv) {

  s32 pid;
  u32 rand_seed;
  int status;
  u8* inst_ratio_str = getenv("AFL_INST_RATIO");

  struct timeval tv;
  struct timezone tz;

  clang_mode = !!getenv(CLANG_ENV_VAR);

  if (isatty(2) && !getenv("AFL_QUIET")) {

    SAYF(cCYA "afl-as " cBRI VERSION cRST " by <lcamtuf@google.com>\n");
 
  } else be_quiet = 1;

  if (argc < 2) {

    SAYF("\n"
         "This is a helper application for afl-fuzz. It is a wrapper around GNU 'as',\n"
         "executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n"
         "don't want to run this program directly.\n\n"

         "Rarely, when dealing with extremely complex projects, it may be advisable to\n"
         "set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n"
         "instrumenting every discovered branch.\n\n");

    exit(1);

  }

  gettimeofday(&tv, &tz);

  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();

  srandom(rand_seed);

  edit_params(argc, argv);

  if (inst_ratio_str) {

    if (sscanf(inst_ratio_str, "%u", &inst_ratio) != 1 || inst_ratio > 100) 
      FATAL("Bad value of AFL_INST_RATIO (must be between 0 and 100)");

  }

  if (getenv(AS_LOOP_ENV_VAR))
    FATAL("Endless loop when calling 'as' (remove '.' from your PATH)");

  setenv(AS_LOOP_ENV_VAR, "1", 1);

  /* When compiling with ASAN, we don't have a particularly elegant way to skip
     ASAN-specific branches. But we can probabilistically compensate for
     that... */

  if (getenv("AFL_USE_ASAN") || getenv("AFL_USE_MSAN")) {
    sanitizer = 1;
    inst_ratio /= 3;
  }

  if (!just_version) add_instrumentation();

  if (!(pid = fork())) {

    int i;
    for (i = 0; as_params[i] != NULL; i++) {
      SAYF("as_params[%d]: %s\n", i, as_params[i]);
    }

    execvp(as_params[0], (char**)as_params);
    FATAL("Oops, failed to execute '%s' - check your PATH", as_params[0]);

  }

  if (pid < 0) PFATAL("fork() failed");

  if (waitpid(pid, &status, 0) <= 0) PFATAL("waitpid() failed");

  if (!getenv("AFL_KEEP_ASSEMBLY")) unlink(modified_file);

  exit(WEXITSTATUS(status));

}

